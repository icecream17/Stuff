# intro #

# Instead of reading all this explanation,
# go to anything you're interested in
# and then read back when you're confused

# Sounds less efficient, but it's easier
# and helps and helps develop knowledge

# And it's actually not less efficient
# since you'll only need some of the information


# If you generally know a topic, skip
# comments surrounded by ------

# ------------------
# example ignore
# words words does this help beginners tho?
# two doubly switch three implies one plus one is three
# ------------------

# By default there's no explanation
# but pictures are worth a thousand words
# look on Wikipedia



# file structure and items #

# This file is a bunch of items and comments

# Items are like functions,
# they receive values
# and output another value

# In this world, inputs are the hypotheses (givens)
# and the output is ... something

item example_item
 some hypothesis
 some given
 some input
assert
 some thing

# This structure is used for everything here
# which are mainly proofs or assertions
# similar to but not exactly
# "given a is a number, a + 0 is a number"


# Identifiers #

# Some naming conventions are below
# But what's really important is:
# what names are possible?

# e.g. What identifiers are valid?

# An identifier can have these characters:
# abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
# 1234567890+×=/_<>[]!@#$%^&*()-'":;,?`~\|{}€£¥₩°¡¿
# •○●□■♤♡◇♧☆▪︎¤《》...

# <unicode moment>

# basically any unicare that's not whitespace,
# control, invisible, non-assigned, deprecated...

# but try to stick to letters and numbers
# or at least chars on the keyboard



# Values and types #

# Remember example_item?
# my attention span is way too low

# looking above it looks like
# All values are preceded by a type

# ----------------
# types can be thought of as collections
# containing all values with some specific
# properties

# for example the type "boolean"
# contains true and false
# ----------------


# items "transform" some typed inputs
# into another, hmm what can this be used for??
# type conversion!!! ...



# "some" is not actually used or defined btw


# Variables #

# types can be followed by a lowercase letter
# in which case it is a variable

# ----------------
# variables that can be replaced with anything
# of the same type...

# as long as the same variables (same letter)
# have the same
# content
# ----------------


# Proofs #

# proofs call previous items with hyps and stps
# and kinda substitutes those with new things
# the last step should be the assertion
# that's it!

# Example: ccat3toks


# Info about certain types #

# Are explained where they are defined



# Hope this was intuitive and easy to understand
# in contrast to headache inducing



# naming #

# an      and
# ax      axiom
# ccat    concatenate
# com     communicative property
# df      definition
# gv      given
# hyp     hypothesis
# ins     insert
# lf      left
# rt      right
# rv      reverse
# stp     step (in a proof)
# syn     syntax
# th      theorem
# tok     token sequence
# tr      transitive property
# tru     a wff that is true
# val     value
# wff     well formed formula


# symbols
# /\      ∧       and



# list of axioms and definitions
# synisitem                     syn a ==> item a
# axisitem                      ax a ==> item a
# dfisitem                      df a ==> item a
# thisitem                      th a ==> item a
# ccattoks                      tok a AND tok b ==> tok a b 
# lf2toksistok                  tok a b ==> tok a
# rt2toksistok                  tok a b ==> tok b
# wffistok                      wff a ==> tok a
# truiswff                      tru a ==> wff a
# sfor                          tru ( a sfor b ) AND tok c AND tok d AND tru c b d ==> tru c a d
# istok                         tok a ==> tru istok a



# syn is actually just an alias for item
item synisitem
 syn a
assert
 item a

# and same with axiom
item axisitem
 ax a
assert
 item a

# and with definition
item dfisitem
 df a
assert
 item a

# theorem
item thisitem
 th a
assert
 item a

# they're used for clarity though
# syn = declaring valid wffs for new things
# def = what something does
# ax = is not proven
# th = proves something



# tok: token sequences
# toki
# Instead of describing the most common logical axioms
# let's describe what mathematical statements even are

# The first axiom
# Combines two toks together
ax ccattoks
 tok a
 tok b
assert
 tok a b

# The first theorem
# Join *three* toks together
th ccat3toks
 tok a
 tok b
 tok c
assert
 tok a b c
proof
 ccattoks hyp1 hyp2 : tok a b
 ccattoks stp1 hyp3 : tok a b c



# The left of two tokens is a tok
ax lf2toksistok
 tok a b
assert
 tok a

# The right of two tokens is a tok
ax rt2toksistok
 tok a b
assert
 tok a



# Extracts the second of three toks
th 2ndof3toksistok
 tok a b c
assert
 tok b
proof
 lf2toksistok hyp1 : tok a b
 rt2toksistok hyp2 : tok b

# Repeat the first tok
th 1stccat
 tok a b
assert
 tok a a b
proof
 lf2toksistok hyp1 : tok a
 ccattoks stp1 hyp1 : tok a a b

th ccat1st
 tok a b
assert
 tok a b a
proof
 lf2toksistok hyp1 : tok a
 ccattoks hyp1 stp1 : tok a b a

# Repeat the last tok
th ccatlast
 tok a b
assert
 tok a b b
proof
 rt2toksistok hyp1 : tok b
 ccattoks hyp1 stp1 : tok a b b

# Repeat the last tok
th lastccat
 tok a b
assert
 tok b a b
proof
 rt2toksistok hyp1 : tok b
 ccattoks stp1 hyp1 : tok b a b



# These theorems depend on all three axioms! I think

# Reverse a token sequence
th rvtok
 tok a b
assert
 tok b a
proof
 ccattoks hyp1 hyp1 : tok a b a b
 2ndof3toksistok stp1 : tok b a

# Removes the second of three toks
th 3toksw/o2ndistok
 tok a b c
assert
 tok a c
proof
 lf2toksistok hyp1 : tok a
 rt2toksistok hyp1 : tok c
 ccattoks stp1 stp2 : tok a c

# Insert a token between two others
th instok@2
 tok a c
 tok b
assert
 tok a b c
proof
 lf2toksistok hyp1 : tok a
 rt2toksistok hyp1 : tok c
 ccat3toks stp1 hyp2 stp2 : tok a b c




# wffs "whiffs" Well formed formulas
# because not all toks are wffs

# wffs are toks
ax wffistok
 wff a
assert
 tok a



# tru, true statements
# again not all wffs are trus

# trus are wffs
ax truiswff
 tru a
assert
 wff a


# trus are toks
th truistok
 tru a
assert
 tok a
proof
 truiswff hyp1 : wff a
 wffistok stp1 : tok a

th truabthentoka
 tru a b
assert
 tok a
proof
 truistok hyp1 : tok a b
 lf2toksistok stp1 : tok a

th truabthentokb
 tru a b
assert
 tok b
proof
 truistok hyp1 : tok a b
 rt2toksistok stp1 : tok b




# Constructs formulas involving substitution
# s will generally be short for "sub"
# like in subset and substring and subtract
#
# sub for
# Define (left) substitution
df sfor
 tru ( a sfor b )
 tok c
 tok d
 tru c b d
assert
 tru c a d

# Identity substitution given a sfor b
th asforagvasforb
 tru ( a sfor b )
assert
 tru ( a sfor a )
proof
 truabthentoka hyp1 : tok ( a sfor
 truabthentokb hyp1 : tok )
 sfor hyp1 stp1 stp2 hyp1 : tru ( a sfor a )

# This used to line up soooo perfectly
#
# abistruthenaistok hyp1 : tok ( a =
# abistruthenbistok hyp1 : )
# eq hyp1 stp1 stp2 hyp1 : tru ( a = a )
#
# but equality is semantically different
# from substitution
#
# and it's practically different because
# equality implies both lf substitution
# and rt substitution
#
# rt substitution is non trivial
# to derive from lf substitution
#
# in fact the only reason it isn't an axiom
# is more powerful language


# Transitive property of subbing
th sfortr
 tru ( a sfor b )
 tru ( b sfor c )
assert
 tru ( a sfor c )
proof
 truabthentoka hyp2 : tok (
 truabthentokb hyp2 : tok sfor c )
 sfor hyp1 stp1 stp2 hyp2 : tru ( a sfor c )


# two things that are equal to the same are equal
# substitution version
th sfortr2
 tru ( a sfor c )
 tru ( b sfor c )
assert
 tru ( a sfor b )
proof
 truabthentoka hyp1 : tok (
 truabthentokb hyp1 : tok sfor c )
 sfor hyp2 stp1 stp2 hyp1 : tru ( a sfor b )

# you can get b subs a by reversing the givens


# communicate sfor given b sfor something
# also used to line up
th sforcomgvbsforc
 tru ( a sfor b )
 tru ( b sfor c )
assert
 tru ( b sfor a )
proof
 asforagvasforb hyp2 : tru ( b sfor b )
 sfortr2 stp1 hyp1 : tru ( b sfor a )





# The "eq" operator (combined with "and")
df eq
assert
 tru ( ( ( a sfor b ) sfor ( a = b ) ) and ( ( b sfor a ) sfor ( a = b ) ) )

# I just realized that under my current definition of substitution,
# it is true that
# tru ( ( ( a sfor ( ( a )

# Sigh





