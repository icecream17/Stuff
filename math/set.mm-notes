# set.mm-notes

## Alternate proofs

bicomd: bicom1 syl
neg0: df-neg 0cn subidi eqtri

## Alternate definition of cgt

See https://js.do/celiasnt/altcgt for some proofs, but basically
here's an alternate definition of combinatorial games:

Fgen = rec((x âˆˆ V â†¦ (ğ’« x Ã— ğ’« x)), âˆ…)
Fg = { x | âˆƒy âˆˆ Ï‰ x âˆˆ (Fgenâ€™y) }

### Definition of cgt addition

Addition will be done later.
But here's the motivation for my future definition of addition:

+s means "add game with set of games"
+cg means "add two games"

Normally these are defined as:

+s = (x âˆˆ Fg, y âˆˆ ğ’« Fg â†¦ { z | âˆƒw âˆˆ y z = (x +cg w) })
+cg = (x âˆˆ Fg, y âˆˆ Fg â†¦ âŸ¨(x +s (1st`y)) âˆª (y +s (1st`x)), (x +s (2nd`y)) âˆª (y +s (2nd`x))âŸ©)

The obvious problem is that these definitions depend on themselves which contrasts
with Metamath's philosophical recursion / easy substitutionally sound definition goals.

So instead define +s to allow any operator:
+sg = (O âˆˆ V â†¦ (x âˆˆ Fg, y âˆˆ ğ’« Fg â†¦ { z | âˆƒw âˆˆ y z = (x O w) }))

Hmm that just pushes the problem to
+s = +sg`+cg
which still depends on +cg which depends on +s

Looking at
+cg = (x âˆˆ Fg, y âˆˆ Fg â†¦ âŸ¨(x +s (1st`y)) âˆª (y +s (1st`x)), (x +s (2nd`y)) âˆª (y +s (2nd`x))âŸ©)

The union of (x +s (1st`y)) âˆª (y +s (1st`x)) is
{ z | (âˆƒw âˆˆ (1st'y) z = (x O w) âˆ¨ âˆƒw âˆˆ (1st'x) z = (y O w)) }

Hmm, what if we use a recursive tool on itself?
Let's define +cg with the unwrapped substitution above and a general operator argument:
+cgug = (O âˆˆ V â†¦ (x âˆˆ Fg, y âˆˆ Fg â†¦ âŸ¨{ z | (âˆƒw âˆˆ (1st'y) z = (x O w) âˆ¨ âˆƒw âˆˆ (1st'x) z = (y O w)) }, { u | (âˆƒt âˆˆ (2nd'y) u = (x O t) âˆ¨ âˆƒt âˆˆ (2nd'x) u = (y O t)) }âŸ©))

Hmm, that doesn't work either... we still need to call +cgug with the right operator,
and the right operator isn't itself, but it also isn't (x âˆˆ Fg, y âˆˆ Fg â†¦ âŸ¨{...
since that definition has the variable O

However all that's needed is for the syntax to expand / unravel forever.

(+cgug`+cgug) takes an operator and has depth 2
((+cgug`+cgug)`(+cgug`+cgug)) has depth 4
... has depth 1024

We then define the result of addition the first time that
A((cgugdepth`N)`F)B = A((cgugdepth`suc N)`F)B

where F = (A âˆˆ V, B âˆˆ V â†¦ if-(B = âˆ…,âˆ…,âŸ¨A, BâŸ©))

Let's try adding 0cg + 0cg
0cg = âŸ¨âˆ…, âˆ…âŸ©
+cgug`F = (x âˆˆ Fg, y âˆˆ Fg â†¦ âŸ¨{ z | (âˆƒw âˆˆ (1st'y) z = (x F w) âˆ¨ âˆƒw âˆˆ (1st'x) z = (y F w)) }, { u | (âˆƒt âˆˆ (2nd'y) u = (x O t) âˆ¨ âˆƒt âˆˆ (2nd'x) u = (y F t)) }âŸ©))
                                      ^ no                         ^ no                                 ^ no                          ^ no
        eval: âŸ¨âˆ…, âˆ…âŸ©
+cgug`(+cgug`F) = ...
        eval: âŸ¨âˆ…, âˆ…âŸ©
        
That was extremely "trivial".
Let's add 1cg + 0cg
1cg = âŸ¨{âŸ¨âˆ…, âˆ…âŸ©}, âˆ…âŸ©
0cg = âŸ¨âˆ…, âˆ…âŸ©
+cgug`F = (x âˆˆ Fg, y âˆˆ Fg â†¦ âŸ¨{ z | (âˆƒw âˆˆ (1st'y) z = (x F w) âˆ¨ âˆƒw âˆˆ (1st'x) z = (y F w)) }, { u | (âˆƒt âˆˆ (2nd'y) u = (x O t) âˆ¨ âˆƒt âˆˆ (2nd'x) u = (y F t)) }âŸ©))
                                      ^ no                                                              ^ no                          ^ no
        eval: âŸ¨{ z | âˆƒw âˆˆ (1st'x) z = (y F w) }, âˆ…âŸ©
            y and w are 0cg:
        eval: âŸ¨âŸ¨0cg, 0cgâŸ©, âˆ…âŸ©
+cgug`(+cgug`F)
        eval: âŸ¨{ z | âˆƒw âˆˆ (1st'x) z = (y (+cgug`F) w) }, âˆ…âŸ©
            since earlier 0cg +cgug`F 0cg resulted in 0cg:
        eval: âŸ¨0cg, âˆ…âŸ©
+cgug`(+cgug`(+cgug`F))
        eval: âŸ¨{ z | âˆƒw âˆˆ (1st'x) z = (y +cgug`(+cgug`F) w) }, âˆ…âŸ©
            since earlier 0cg +cgug`(+cgug`F) 0cg resulted in 0cg:
        eval: âŸ¨0cg, âˆ…âŸ©

Wow, that also worked.
Not sure if F is guaranteed to work, I just made F up.

But in principle, through this really daunting and complicated construction, combinatorial addition can be defined.

There are more operators though...
        
