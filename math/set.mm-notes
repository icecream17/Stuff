# set.mm-notes

## Alternate proofs

bicomd: bicom1 syl
neg0: df-neg 0cn subidi eqtri

## Alternate definition of cgt

See https://js.do/celiasnt/altcgt for some proofs, but basically
here's an alternate definition of combinatorial games:

Fgen = rec((x âˆˆ V â†¦ (ð’« x Ã— ð’« x)), âˆ…)
Fg = { x | âˆƒy âˆˆ Ï‰ x âˆˆ (Fgenâ€™y) }

### Definition of cgt addition

Addition will be done later.
But here's the motivation for my future definition of addition:

+s means "add game with set of games"
+cg means "add two games"

Normally these are defined as:

+s = (x âˆˆ Fg, y âˆˆ ð’« Fg â†¦ { z | âˆƒw âˆˆ y z = (x +cg w) })
+cg = (x âˆˆ Fg, y âˆˆ Fg â†¦ âŸ¨(x +s (1st`y)) âˆª (y +s (1st`x)), (x +s (2nd`y)) âˆª (y +s (2nd`x))âŸ©)

The obvious problem is that these definitions depend on themselves which contrasts
with Metamath's philosophical recursion / easy substitutionally sound definition goals.

So instead define +s to allow any operator:
+sg = (O âˆˆ V â†¦ (x âˆˆ Fg, y âˆˆ ð’« Fg â†¦ { z | âˆƒw âˆˆ y z = (x O w) }))

Hmm that just pushes the problem to
+s = +sg`+cg
which still depends on +cg which depends on +s

Looking at
+cg = (x âˆˆ Fg, y âˆˆ Fg â†¦ âŸ¨(x +s (1st`y)) âˆª (y +s (1st`x)), (x +s (2nd`y)) âˆª (y +s (2nd`x))âŸ©)

The union of (x +s (1st`y)) âˆª (y +s (1st`x)) is
{ z | (âˆƒw âˆˆ (1st'y) z = (x O w) âˆ¨ âˆƒw âˆˆ (1st'x) z = (y O w)) }

Hmm, what if we use a recursive tool on itself?
Let's define +cg with the unwrapped substitution above and a general operator argument:
+cgug = (O âˆˆ V â†¦ (x âˆˆ Fg, y âˆˆ Fg â†¦ âŸ¨{ z | (âˆƒw âˆˆ (1st'y) z = (x O w) âˆ¨ âˆƒw âˆˆ (1st'x) z = (y O w)) }, { u | (âˆƒt âˆˆ (2nd'y) u = (x O t) âˆ¨ âˆƒt âˆˆ (2nd'x) u = (y O t)) }âŸ©))

And now
+cg = +cgug`+cgug

Tada! A definition of +cg that doesn't have itself in the definition.
It uses +cgug, the definition of +cgug doesn't have itself in the definition, but it can be called with itself -> recursion!

This suggests a new tool to define recursive things without actually including itself:
1. create a function that takes an operator and does the same thing as the goal operator would do
2. call function with operator
