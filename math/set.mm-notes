# set.mm-notes

## Alternate proofs

bicomd: bicom1 syl
neg0: df-neg 0cn subidi eqtri

## Alternate definition of cgt

See https://js.do/celiasnt/altcgt for some proofs, but basically
here's an alternate definition of combinatorial games:

Fgen = rec((x ∈ V ↦ (𝒫 x × 𝒫 x)), ∅)
Fg = { x | ∃y ∈ ω x ∈ (Fgen’y) }

### Definition of cgt addition

Addition will be done later.
But here's the motivation for my future definition of addition:

+s means "add game with set of games"
+cg means "add two games"

Normally these are defined as:

+s = (x ∈ Fg, y ∈ 𝒫 Fg ↦ { z | ∃w ∈ y z = (x +cg w) })
+cg = (x ∈ Fg, y ∈ Fg ↦ ⟨(x +s (1st`y)) ∪ (y +s (1st`x)), (x +s (2nd`y)) ∪ (y +s (2nd`x))⟩)

The obvious problem is that these definitions depend on themselves which contrasts
with Metamath's philosophical recursion / easy substitutionally sound definition goals.

So instead define +s to allow any operator:
+sg = (O ∈ V ↦ (x ∈ Fg, y ∈ 𝒫 Fg ↦ { z | ∃w ∈ y z = (x O w) }))

Hmm that just pushes the problem to
+s = +sg`+cg
which still depends on +cg which depends on +s

Looking at
+cg = (x ∈ Fg, y ∈ Fg ↦ ⟨(x +s (1st`y)) ∪ (y +s (1st`x)), (x +s (2nd`y)) ∪ (y +s (2nd`x))⟩)

The union of (x +s (1st`y)) ∪ (y +s (1st`x)) is
{ z | (∃w ∈ (1st'y) z = (x O w) ∨ ∃w ∈ (1st'x) z = (y O w)) }

Hmm, what if we use a recursive tool on itself?
Let's define +cg with the unwrapped substitution above and a general operator argument:
+cgug = (O ∈ V ↦ (x ∈ Fg, y ∈ Fg ↦ ⟨{ z | (∃w ∈ (1st'y) z = (x O w) ∨ ∃w ∈ (1st'x) z = (y O w)) }, { u | (∃t ∈ (2nd'y) u = (x O t) ∨ ∃t ∈ (2nd'x) u = (y O t)) }⟩))

And now
+cg = +cgug`+cgug

Tada! A definition of +cg that doesn't have itself in the definition.
It uses +cgug, the definition of +cgug doesn't have itself in the definition, but it can be called with itself -> recursion!

This suggests a new tool to define recursive things without actually including itself:
1. create a function that takes an operator and does the same thing as the goal operator would do
2. call function with operator
